---
title: "Cálculo de spatial clustering"
output: html_notebook
---

# Cargamos librerías 

```{r}
suppressMessages(library(tidyverse))
```

# Cargamos dataset con grifos y vecinos

```{r}
grifos <- readRDS(here::here("data","processed","grifo_con_vecinos.rds"))

glimpse(grifos)
```

Tomemos un grifo cercano a mi casa y conocido para ver que esté bien la función anterior:

```{r}
grifos %>%
    filter(razon_social.princ == "INVERSIONES MAVU S.A.C.") %>%
    select(
        codigo_de_osinergmin.princ,
        razon_social.princ,
        bandera.princ,
        codigo_de_osinergmin.vec,
        razon_social.vec,
        bandera.vec
    )
```


# Funciones


```{r}

hallar_bandera <- function(cod1) {
    # se debe tener cargado el ouput de 2.5 estaciones thiessen
    #input: codigo del grifo
    #ouput: bandera del grifo
    grifos %>% 
        filter(codigo_de_osinergmin.princ == cod1) %>%
        distinct(bandera.princ) %>% 
        pull()
}

hallar_lista_vecinos <- function(cod1) {
    # se debe tener cargado el ouput de 2.5 estaciones thiessen
    #input: codigo del grifo
    #ouput: vector con codigos de vecinos    
    grifos[grifos$codigo_de_osinergmin.princ == cod1, ]$codigo_de_osinergmin.vec
}


hallar_lista_vecinos(17947)
hallar_lista_vecinos(14665)
```


```{r}
hallar_cluster <- function(cod) {
    #halla todas las estaciones vecinas que tienen la misma bandera
    #input: codigo de la estación
    #output: dataframe que tiene todas las estacioens del cluster de cod,
    #        incluida cod, con razón social y bandera
    
    df1 <- filter(grifos, codigo_de_osinergmin.princ == cod) %>%
        distinct(codigo_de_osinergmin.princ,
                 razon_social.princ,
                 bandera.princ)
    bandera <- hallar_bandera(cod)
    lista_vecinos <- hallar_lista_vecinos(cod)
    df2 <- filter(grifos,
                  codigo_de_osinergmin.princ %in% lista_vecinos,
                  bandera.princ == bandera) %>%
        distinct(codigo_de_osinergmin.princ,
                 razon_social.princ,
                 bandera.princ)
    bind_rows(df1, df2)
}

hallar_cluster(8153)

```

```{r}
hallar_todos_cluster <- function(cod) {
    #halla todas las que están en mismo cluster (a nivel de banderas) que cod,
    #sin importar el nivel
    #input: codigo de la estación
    #output: dataframe que tiene todas las estaciones del cluster de cod,
    #        incluida cod, con razón social y bandera
    if (hallar_bandera(cod) == "INDEPENDIENTE") {
        df1 <- filter(grifos, codigo_de_osinergmin.princ == cod) %>%
            distinct(codigo_de_osinergmin.princ,
                     razon_social.princ,
                     bandera.princ)
        return(df1)
    }
    i <- 1
    df <- hallar_cluster(cod)
    
    while (i < nrow(df)) {
        df <-
            bind_rows(df, hallar_cluster(df$codigo_de_osinergmin.princ[i + 1])) %>%
            distinct()
        i <- i + 1
    }
    
    arrange(df, codigo_de_osinergmin.princ)
}

#cluster de 1
hallar_todos_cluster(14646)
#cluster de 2 
hallar_todos_cluster(19956)
#cluster independiente
hallar_todos_cluster(62240)


```

```{r}
#hacemos un loop para quedarnos solo con los que no son repetidos

comprobar_df_dup <- function(df1, df2) {
    #Funcionar para comprobar si dos dataframes son iguales. Es para elimitar los 
    #dataframes de vecinos del mismo cluster que se generan
    #input: dos df con codigo | razon_social | bandera
    #output: TRUE si son iguales, FALSE de lo contrario
    if (is.null(df1) | is.null(df2)) {
        return(FALSE)
    }
    if (nrow(df1) == nrow(df2)) {
        if (all(df1 == df2)) {
            return(TRUE)
        } else {
            return(FALSE)
        }
    } else {
        return(FALSE)
    }
}
#Prueba, debería retornar verdadero

comprobar_df_dup(hallar_todos_cluster(17944), hallar_todos_cluster(94684))

#debería retornar falso
comprobar_df_dup(hallar_todos_cluster(17944), hallar_todos_cluster(19956))

#nulo versus df
comprobar_df_dup(NULL, hallar_todos_cluster(19956))


```


Vemos que funciona, así que empaquetemos en una función:

```{r}

hallar_clusteres_mercado <- function(cod) {
    #halla todos clusteres del mercado que genera el grifo cod
    #input: codigo de la estación
    #output: lista que contiene dataframes con cada cluster que rodea a la 
    #estación cod
    df1 <- grifos %>% filter(codigo_de_osinergmin.princ == cod) %>%
        select(codigo = codigo_de_osinergmin.princ,
               razon_social = razon_social.princ,
               bandera = bandera.princ) %>% distinct()
    df2 <- grifos %>% filter(codigo_de_osinergmin.princ == cod) %>%
        select(codigo = codigo_de_osinergmin.vec,
               razon_social = razon_social.vec,
               bandera = bandera.vec)
    
    grifo_con_vecinos <- bind_rows(df1, df2)
    #creamos lista con cluster de cada grifo (pueden haber repetidos)
    
    lista <- list()
    
    for (grifo in grifo_con_vecinos$codigo) {
        lista[[as.character(grifo)]] <- hallar_todos_cluster(grifo)
    }
    
    #removemos los df repetidos (que normalmente habrá si hay vecinos en el mercado
    #del mismo cluster)
    for (i in 1:(length(lista) - 1)) {
        for (j in (i + 1):length(lista)) {
            if (comprobar_df_dup(lista[[i]], lista[[j]])) {
                lista[j] <- list(NULL)
            }
        }
    }
    
    lista[sapply(lista, is.null)] <- NULL
    lista
}

hallar_clusteres_mercado(19956)
str(hallar_clusteres_mercado(14665))

```


Creamos función de spatial clustering (a nivel de banderas):

```{r}
calcular_sc <- function(cod) {
    #numero de grifos en el mercado local
    N <- length(hallar_lista_vecinos(cod)) + 1
    #número de clusteres
    (M <- length(hallar_clusteres_mercado(cod)))
    #suma número de estaciones en cada cluster
    suma_clusteres <- sum(sapply(hallar_clusteres_mercado(cod), nrow))
    suma_clusteres
    #medida de spatial cluster 
    sc <- suma_clusteres / M / N
    sc
}

calcular_sc(14665)
calcular_sc(19956)

```

# Test de la función

La prueba la haremos con el grifo 14645 (Pecsa en el cruce de Cuba con Arenales). A la fecha de hoy (2019-03-29), se tiene para el grifo:
- N = 8
- M = 5 (Primax, dos de Pecsa, Repsol, Independiente):
    * k_repsol = 9
    * k_primax_1 = 1
    * k_primax_2 = 5
    * k_pecsa = 1
    * k_independiente = 1
Por tanto el valor de sc es $sc = \frac{(9+1+5+1+1)/5}{8} = 0.425$. Verificamos que sea el mismo valor

```{r}
if (all.equal(calcular_sc(14645), 0.425)) {
    "Función calcular_sc pasa la prueba"
} else {
    stop("Función calcular_sc no pasa la prueba")

}
```

